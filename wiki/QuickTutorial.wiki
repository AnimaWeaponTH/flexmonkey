#summary FlexMonkey Tutorial.
#labels Featured

_Updated for FlexMonkey 0.6. For 0.5, see the [QuickTutorialForZeroDotFive old tutorial]._

= Running the Sample Application =

This tutorial will walk through the features of flexmonkey by using it to test a simple contact manager application. The running application should be embedded here:


<wiki:gadget url="http://keystone.gorillalogic.com/~sstern/fm06/flash_container.xml" height="600" width="800"></wiki:gadget>

Please [http://code.google.com/p/flexmonkey/downloads/list download] the source and binaries.

The sample consists of the following components:

  * *!MonkeyContacts.mxml* - the source file for the Monkey Contact Application we'll be testing.
  * *!FlexUnitTests.as* - source code containing a test previously generated by flexmonkey.
  * *FlexMonkeyTests.mxml* - an application that invokes the tests contained in !FlexUnitTests.as. 
  * *!MonkeyContactsTest.html* - An html page that passes parameters (via flashvars) to !FlexMonkeyLauncher.swf, which is a component of the !FlexMonkey framework used to run applications and tests.

!MonkeyContacts.mxml contains no flexmonkey-specific code. Any application can be tested with flexmonkey without requiring any source or binary modifications.

As mentioned above, *!FlexMonkeyLauncher.swf* launches a swf to be tested. !FlexMonkeyLauncher provides the Flex automation API as well as the flexmonkey API and user interface needed for creating and running tests. Prior to !FlexMonkey 0.6, it was necessary to create a special version of your application swf that was linked with the !FlexMonkey and Flex Automation libraries. Now however, !FlexMonkeyLauncher provides these dynamically to any application it loads, so the swf you test can be the very same swf as the one you will deploy into production.

To use !FlexMonkey, you start the !FlexMonkeyLauncher and pass it the name of the swf file to be tested. To test the !MonkeyContacts app, we open build/FlexMonkeyTest.html in a browser. !FlexMonkeyTest.html simply starts FlexMonkeyLauncher and passes it the name of the swf to run:

{{{
<html>
<head>
<title>FlexMonkeyLauncher</title>
<style>
body { margin: 0px;
 overflow:hidden }
</style>
</head>
<body scroll='no'>


    <object id='FlexMonkeyRunner' classid='clsid:D27CDB6E-AE6D-11cf-96B8-444553540000' codebase='http://fpdownload.macromedia.com/get/flashplayer/current/swflash.cab' height='100%' width='100%'>
        <param name='src' value='FlexMonkeyLauncher.swf'/>
        <param name='flashVars' value='targetSwf=MonkeyContacts'/>
        <embed name='mySwf' src='FlexMonkeyLauncher.swf' pluginspage='http://www.adobe.com/go/getflashplayer' height='100%' width='100%' flashVars='targetSwf=MonkeyContacts'/>
    </object>

</body>
</html>
}}} 

The swf to launch is specified using a [http://livedocs.adobe.com/flex/3/html/help.html?content=passingarguments_3.html flashvar] called *targetSwf*. Notice that the targetSwf parameter is specified twice. The *param* tag specifies it for IE browsers, and the *embed* tag specifies it for non-IE ones. You only need to use both if you'll be testing in multiple browser types.

When you open !FlexMonkeyTest.html in a browser, the !MonkeyContacts application window opens, and the !FlexMonkey window opens on top of it. You can move and resize the !Flexmonkey window as necessary to work with the contact manager app beneath it.

You can use !FlexMonkeyTest.html as a template for creating an html wrapper for launching any application for testing.

= Recording a Script =

Click the *Record* toggle button at the top of the screen. Now play around with the contact manager, which although primitive, offers a variety of UI gestures you can record. In addition to typing in the form, you can edit rows after they've been added to the grid, and the Phone Type field has a !ComboBox itemEditor. !Flexmonkey will faithfully record all UI events (many events such as mousemoves are filtered by default). !Flexmonkey displays each recorded event as a command in the Command List. Clicking anywhere in the Flexmonkey window will stop recording.

http://flexmonkey.googlecode.com/svn/trunk/FlexMonkey/docs/images/screenShot1.png

= Playing Back a Script =

Click the Play button on the Command List window. Each recorded action will be replayed. By default, !Flexmonkey pauses for a half second between commands to give each UI action time to complete.

You can play subsets of commands from the list by selecting them in the grid and then hitting Run. If no rows are selected, !Flexmonkey will play all the commands. 

= Generating a !FlexUnit Test =

Click on the FlexUnit TestCase tab to view the generated source code. Two methods are generated, the first calls !FlexMonkey.runCommands passing it an array of !FlexCommands generated from the Flexmonkey Command List. The second method contains a stub body where you would write actual validation code specific to what's being tested by the command sequence. You can copy and paste this code into a !FlexUnit !TestCase and add it to any !FlexUnit !TestSuite. (With minor modifications, the source can be used with other automated testing suites besides !FlexUnit).

http://flexmonkey.googlecode.com/svn/trunk/FlexMonkey/docs/images/screenShot3.png

Click the *Show completeTestCase* checkbox and a complete !FlexUnit !TestCase will be generated.

http://flexmonkey.googlecode.com/svn/trunk/FlexMonkey/docs/images/screenShot4.png

Copy and paste the generated code into an !ActionScript source file and add testing validations such as what's shown here:

{{{
package test
{
	import com.gorillalogic.flexmonkey.commands.CallCommand;
	import com.gorillalogic.flexmonkey.commands.CommandRunner;
	import com.gorillalogic.flexmonkey.commands.FlexCommand;
	import com.gorillalogic.flexmonkey.core.MonkeyEvent;
	import com.gorillalogic.flexmonkey.core.MonkeyUtils;
	
	import flexunit.framework.Assert;
	import flexunit.framework.TestCase;
	
	import mx.collections.ArrayCollection;
	import mx.controls.DataGrid;
	import mx.controls.DateField;


	public class FlexUnitTests extends TestCase {

	// Test method
	public function testSomething():void {
		var cmdRunner:CommandRunner = new CommandRunner();
		cmdRunner.addEventListener(MonkeyEvent.READY_FOR_VALIDATION, addAsync(verifySomething, 10000));
		cmdRunner.runCommands([
			new FlexCommand("inName", "SelectText", ["0", "0"], "automationName"),
			new FlexCommand("inName", "Input", ["Fred"], "automationName"),
			new FlexCommand("inType", "Open", ["null"], "automationName"),
			new FlexCommand("inType", "Select", ["Work", "1", "0"], "automationName"),
			new FlexCommand("inPhone", "SelectText", ["0", "0"], "automationName"),
			new FlexCommand("inPhone", "Input", ["555 555 5555"], "automationName"),
			// The following command was inserted manually to demonstrate a workaround for DateField bug
			// See http://groups.google.com/group/flexmonkey/browse_thread/thread/bf4af5e1d8164608# for more info
			new CallCommand(function():void {DateField(MonkeyUtils.findComponentWith("inDate")).open()}),			
			new FlexCommand("inDate", "Open", ["null"], "automationName"),
			new FlexCommand("inDate", "Change", ["Fri Dec 26 2008"], "automationName"),
			new FlexCommand("Add", "Click", ["0"], "automationName")
]);
   }
	// Called after commands have been run
	private function verifySomething(event:MonkeyEvent):void {
		   var comp:DataGrid = MonkeyUtils.findComponentWith("grid","id") as DataGrid;
		   Assert.assertEquals("Fred", ArrayCollection(comp.dataProvider).getItemAt(0).name);
		   Assert.assertEquals("Work", ArrayCollection(comp.dataProvider).getItemAt(0).type);		   

	}   }
}

}}}

Let's examine the code. First, we need a CommandRunner to run our FlexMonkey commands. 

{{{
		var cmdRunner:CommandRunner = new CommandRunner();
}}}

Next, we have to tell !FlexUnit that the test is asynchronous. After Flexmonkey completes running a command list, he dispatches a *READY_FOR_VALIDATION* event. We use !FlexUnit !TestCase's addAsync method to tell !FlexUnit that our *READY_FOR_VALIDATION* event handler's completion signals that the test has passed (unless of course one of our assertions fails). (Learn [http://www.adobe.com/cfusion/communityengine/index.cfm?event=showdetails&productId=2&postId=6882 more] about asynchrounous testing with !FlexUnit).

{{{
		cmdRunner.addEventListener(MonkeyEvent.READY_FOR_VALIDATION, addAsync(verifySomething, 10000);
}}}

The second argument to addAsync tells !FlexUnit to fail the test if the event is not received within 10 seconds. 

The handler passed to addAsync is where you would typically write your validation code:

{{{
	private function verifySomething(event:MonkeyEvent):void {
	   var comp:DataGrid = MonkeyUtils.findComponentWith("grid","id") as DataGrid;
	   Assert.assertEquals("Fred", ArrayCollection(comp.dataProvider).getItemAt(0).name);
	   Assert.assertEquals("Work", ArrayCollection(comp.dataProvider).getItemAt(0).type);		   
	}
}}}

You can easily access UI components using the MonkeyUtils.findComponentWith() Method.

{{{
		/**
		 * Find the first component with the specified property/value pair. If a container is specified, then
		 * only its children and descendents are searched. The search order is (currently) indeterminate. If no container is specified,
		 * then all components will be searched. If the prop value is "automationID", then the id is resolved directly without searching.
		 */
		public static function findComponentWith(value: String, prop:String="automationName", container:UIComponent=null):UIComponent
}}}

You can then examine component properties to determine if the script has produced the expected state using standard !FlexUnit assertions.

{{{
	   Assert.assertEquals("Fred", ArrayCollection(comp.dataProvider).getItemAt(0).name);
	   Assert.assertEquals("Work", ArrayCollection(comp.dataProvider).getItemAt(0).type);		
}}}

The testSomething method adds a row to the table and we're checking that the columns in its first row have the expected name and phone type, "Fred" and "Work".

= Packaging your tests as a SWF =

We can package the tests in their own swf so that they're run by !FlexMonkey without being linked directly into your application swf. In this way, no test code gets included with your deployed application.

We package up the tests into their own swf by invoking them from a (trivial) application such as !FlexMonkeyTests.mxml:

{{{
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" creationComplete="create()">
	<mx:Script>
		<![CDATA[
			import test.FlexUnitTests;
			import com.gorillalogic.flexmonkey.ui.FlexMonkey;
			public function create():void {
			   // Run with the FlexMonkey's built-in testrunner
		     	   FlexMonkey.addTestSuite(FlexUnitTests);

			}
		]]>
	</mx:Script>
</mx:Application>
}}}

As you can see, all this application is doing is adding our tests contained in !FlexUnitTests.as to !FlexMonkey's built-in flexunit runner. We would use a slightly different application for launching tests from ant. (Learn more).

You can use !FlexMonkeyTests.mxml as a template for creating a wrapper application packaging your tests as a separate swf. 

= Running !FlexUnit Tests =

Next we compile !FlexMonkeyTests.mxml into !FlexMonkeyTests.swf. In order to tell !FlexMonkey about our test swf, we add an additional  [http://livedocs.adobe.com/flex/3/html/help.html?content=passingarguments_3.html flashvar] called *testSwf* to our !MonkeyContactsTest.html wrapper:

{{{
<html>
<head>
<title>FlexMonkeyLauncher</title>
<style>
body { margin: 0px;
 overflow:hidden }
</style>
</head>
<body scroll='no'>


    <object id='FlexMonkeyRunner' classid='clsid:D27CDB6E-AE6D-11cf-96B8-444553540000' codebase='http://fpdownload.macromedia.com/get/flashplayer/current/swflash.cab' height='100%' width='100%'>
        <param name='src' value='FlexMonkeyLauncher.swf'/>
        <param name='flashVars' value='targetSwf=MonkeyContacts&testSwf=FlexMonkeyTests'/>
        <embed name='mySwf' src='FlexMonkeyLauncher.swf' pluginspage='http://www.adobe.com/go/getflashplayer' height='100%' width='100%' flashVars='targetSwf=MonkeyContacts&testSwf=FlexMonkeyTests'/>
    </object>

</body>
</html>
}}} 

Open !MonkeyContactsTest.html in a browser. Click on the *Test Runner* tab and click the *Run* button to run the tests.


http://flexmonkey.googlecode.com/svn/trunk/FlexMonkey/docs/images/screenShot5.png

= Testing Server-based SWF's =

Simply deploy !FlexMonkeyLauncher.swf, the test swf (!FlexMonkeyTests.swf) and the html wrapper (!MonkeyContactsTest.html) to the directory on the server containing the app to be tested (!MonkeyContacts.swf). Then open the wrapper in a browser specifying the full url, for example, `http://localhost:8080/myapp/MonkeyContactsTest.html`.

= Understanding Recorded Commands =

The !FlexAutomationAPI dispatches [http://livedocs.adobe.com/flex/3/langref/index.html AutomationRecordEvent]s containg an event name, an array of argument objects, and a reference to the target component. Flexmonkey checks for the existence of a property value it can use to identify the component on playback. Properties are searched in the following sequence:

  # automationName
  # id
  # automationID

Many (most?) Flex components generate an automationName using some logically identifying value. A Button, for example, has a default automationName set to its label. The !FlexAutomationAPI generates an [http://livedocs.adobe.com/flex/3/langref/index.html AutomationID] for every component, so every recorded command is guaranteed to provide an identifier value. automationID's are however derived by serializing the component tree from the component back to the root, and is therefore a very long and very unreadable string. If you want your tests to be readable and (human) modifiable, you will want to assign components id's or automationNames. Alternatively, you can modify a command to use a specific property-value pair, as described below.

= Modifying Recorded Commands =


You can clear all commands from the lists by clicking the *Clear* button. You can delete individual commands by clicking the delete-icon to the left of each command. Toggling the *Record* button on will add newly recorded commands to the end of the list.

Clicking the *Enable editing* checkbox will allow you to modify the recorded commands. (You cannot currently edit the *Arguments* column). You can change the Value and Property columns to any property-value pair you want to use to identify the component. Flexmonkey will return the first component found containing the pair, and the search order is indeterminate. You can limit the search to the children of a component identified by the Container Value and Container Property columns. If no Container values are specified, the search considers all components. (Specifically, all "raw" descendants of the [http://livedocs.adobe.com/flex/2/langref/mx/managers/SystemManager.html SystemManager]).

As an additional aid in developing tests, !FlexMonkey includes [FlexSpy http://code.google.com/p/fxspy/] to allow you to inspect the !UIComponent tree comprising your app. To start !FlexSpy, click on the *!FlexSpy* button on the *!Command List* tab.

= Understanding !FlexCommands =

Flexmonkey generates FlexCommands from your recorded commands, and you can of course easily change or create them in source code, or generate command sequences programmatically.

{{{
		/**
		 * Generate a flex event for the component identified by the specified 
		 * property-value pair.
		 * 
		 * @param value the value to search for
		 * @param name the name of the event to generate
		 * @param args the event args
		 * @param prop the property to search for the specified value. Defaults to automationName.
		 * @param containerValue if specified, only children/descendants of the container having this property value will be searched.
		 * @param containerProp The property to search for the specified containerValue. If no containerProperty-containerValue pair is specified, all components will be searched.
		 */ 	
		public function FlexCommand(value:String, name:String, args:Array = null, prop:String = "automationName", containerValue:String = null, containerProp:String = null)
}}}

For example: 

{{{
// Click the "Add" button 100 times.
for (i:int=0; i < 100; i++) {
   var cmd:FlexCmmand = new FlexCommand("Click","Add",["0"],"label"]);
   cmds[i] = cmd;
}

runCommands(cmds);
}}}

= Adding Pauses to your Script =

All commands are executed asynchronously, and it can sometimes be necessary to force a command to wait additional time before executing during playback. You can do this by adding !PauseCommands to the Array you pass to !FlexMonkey.runCommands(). 

{{{
		/**
		 * Pause for the specified delay time
		 * @param delay in milliseconds
		 */ 
		public function PauseCommand(delay:int)
}}}

By default, !Flexmonkey pauses 5 seconds between command invocations during playback.

Here's an example of adding a pause to a script:

{{{
		cmdRunner.runCommands([
			new FlexCommand("inName", "SelectText", ["0", "0"], "automationName"),
			new PauseCommand(2500),
			new FlexCommand("inName", "Input", ["Fred"], "automationName")]);
	}
}}}


= Calling Functions from Your Script =

Sometimes you might want to execute some actionscript code between commands, for example, to test some assertions. You can insert a function call between commands with a !CallCommand:

{{{
		/**
		 * Call a function during playback
		 * @param func the function to call
		 */ 
		public function CallCommand(func:Function)
}}}

Here's an example of calling a function within a script:

{{{
		cmdRunner.runCommands([
			new FlexCommand("inName", "SelectText", ["0", "0"], "automationName"),
			new CallCommand(checkSomething),
			new FlexCommand("inName", "Input", ["Fred"], "automationName")]);

}}}

= Getting help =

Check out the discussion board at http://groups.google.com/group/flexmonkey.

= Contributing to Flexmonkey =

Why don't you?


 